// Generated by CoffeeScript 1.6.3
(function() {
  var ClientSocket, OssecClient, ProcessOssecJsonAlert, fs, io, optimist, root,
    __slice = [].slice;

  optimist = require('optimist');

  io = require('socket.io-client');

  fs = require('fs');

  ProcessOssecJsonAlert = require('./parsers/process_ossec_json_alert');

  root = global;

  root.debug = true;

  OssecClient = (function() {
    function OssecClient() {}

    OssecClient.prototype.run = function() {
      var argv;
      this.io = new ClientSocket();
      optimist.usage('Uncommon Data OSSEC Adapter');
      optimist.options('a', {
        alias: "alerts",
        describe: 'Read OSSEC alert.log file (expecting default format)',
        "default": process.argv.f
      });
      optimist.options('f', {
        alias: "file",
        describe: 'Syslog file containing OSSEC JSON alerts',
        "default": process.argv.f
      });
      optimist.options('s', {
        alias: "STDIN",
        describe: 'Read from STDIN (expecting Syslog file w/OSSEC JSON alerts)'
      });
      optimist.options('h', {
        alias: "help",
        describe: 'Show this message'
      });
      argv = optimist.argv;
      if (argv.f) {
        return this.readFromSyslogFile(argv.f);
      } else if (argv.s) {
        return this.readFromStdIn();
      } else if (argv.a) {
        return this.readFromAlertsFile(argv.a);
      } else {
        return console.log(optimist.help());
      }
    };

    OssecClient.prototype.readFromStdIn = function() {
      var stdin,
        _this = this;
      stdin = process.openStdin();
      stdin.setEncoding('utf8');
      return stdin.on('data', function(ossec_syslog_alert) {
        return _this.processLine(ossec_syslog_alert, "syslog");
      });
    };

    OssecClient.prototype.readFromSyslogFile = function(filePath) {
      var last, stream,
        _this = this;
      stream = fs.createReadStream(filePath, 'utf8');
      last = "";
      return stream.on('data', function(chunk) {
        var lines, logLine, _i, _j, _len, _ref, _results;
        lines = (last + chunk).replace(/\\\|/g, '').split("\n");
        _ref = lines, lines = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), last = _ref[_i++];
        _results = [];
        for (_j = 0, _len = lines.length; _j < _len; _j++) {
          logLine = lines[_j];
          _results.push(_this.processLine(logLine, "syslog"));
        }
        return _results;
      });
    };

    OssecClient.prototype.readFromAlertsFile = function(filePath) {};

    OssecClient.prototype.processLine = function(logLine, format) {
      var event;
      if (format === "syslog") {
        this.processAlert = new ProcessOssecJsonAlert(logLine);
        event = this.processAlert.run();
      } else if (format === "ossec") {
        this.processAlert = new ProcessOssecAlertLog(logLine);
        event = this.processAlert.run();
      }
      if (event) {
        return this.io.emit(event);
      }
    };

    return OssecClient;

  })();

  ClientSocket = (function() {
    function ClientSocket() {
      var config, url,
        _this = this;
      this.buffer = [];
      if (debug) {
        console.log("Establishing socket.io connection... ");
      }
      config = {
        key: "56dd2065956030fe1c6016dc04917ded",
        host: "localhost",
        port: 5000
      };
      url = "http://" + config.host + ":" + config.port;
      this.ready = false;
      this.socket = io.connect(url);
      this.socket.on("connect", function() {
        console.log("connection established");
        return _this.socket.emit("identify", config.key, function(response) {
          if (response === "ok") {
            console.log("identity verified");
            return _this.ready = true;
          } else {
            return console.log("error, invalid api key");
          }
        });
      });
      this.socket.on("disconnect", function() {
        return _this.ready = false;
      });
    }

    ClientSocket.prototype.emit = function(event) {
      var _results;
      if (this.ready) {
        console.log("emit...");
        if (debug) {
          console.log(event);
        }
        this.socket.emit('message', [event]);
        _results = [];
        while (this.buffer.length > 0) {
          _results.push(this.socket.emit('message', [this.buffer.pop]));
        }
        return _results;
      } else {
        this.buffer.push(event);
        return console.log("error: socket not ready, adding event to buffer, total # buffered alerts = " + this.buffer.length);
      }
    };

    return ClientSocket;

  })();

  new OssecClient().run();

}).call(this);
